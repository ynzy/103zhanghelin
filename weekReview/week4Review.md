数据扁平化
---

* js库 normalizr
* 作用
    > 把从后端传过来的数据中深层嵌套的对象提取出来，提到第一层上。作为一个实体。
    并在原来的字段上置上对应实体的id索引(可以不是id，只要是可以唯一确定不同实体的值即可，一般是用id)
* 思想

    * 数据实体在第一层上分类存储
    * 添加冗余其实又不冗余
        * 看似在每个实体集合加了id字段作为主键，并分出一个result去存储这些id，是增加了冗余，但是在应对多个对象的某一字段是重复的值的时候，如果把它拆出来，事实上是消除了冗余。

* 为什么要对数据进行扁平化?

    * 复杂的对象拥有复杂的字段以及这些字段对应的值拥有不同深度的层级关系(数据嵌套问题)。
    * 修改或查询某一对象的值得时候遍历很浪费性能。

* 怎么做

    * 我们可以通过把这些深层的数据抽取出来作为一类实体的对象集合,这个对象集合其实也是一个对象，不过它内部的每个实体的id就是它的不同键值。
    * 其他数据如果要用到这个实体集合中的某一个实体，只需得到对应的id即可。

* 效果
    * 大大降低了查询和修改某一对象实体的时间复杂度，而用户操作最频繁的也往往是查询和修改。
    * 同一类数据被抽解出来放到不同的对象集合中去。
* 深入理解    

    * 数据原子化。
        * 即有很多种零件箱子(实体Entities)，你要组装一个东西(扁平化之前的对象)，只需要一份组装图(扁平化之后的对象),这个图上写好了各个部分所需要的零件以及它们的型号(扁平后对象字段对应的id),此时你只需要根据组装图找到对应的零件箱子拿出特定型号的零件就可以完成组装。**而扁平化，也就是上述过程的逆过程。"把电视拆了然后零件分门别类的整理好"**
    * 单一数据源
        * 代码在后期维护的时候免不了修改，如果同样的代码写在了很多地方，或者同样的数据放在了很多地方，那么同样，以后修改的时候也会修改很多地方。
        * normalizr不仅使得数据变得扁平，解决了遍历带来的性能损耗，利用它还可以配置单一数据源。
        * 不同类的实体可以交给不同的reducer去处理，别的实体如果要用的这个实体，只需得到它的引用即可。真实实体一旦发生改变，所有引用它的实体对应字段也会同步改变。


* 实例 --- 你小时候拆过电视吗
    * schema(电视结构图)
    schema描述的是一种规则，也就是给你一台电视，你想怎么拆，你要根据什么拆，(瞎拆你是装不回去的)。
    ```js
        const TVSchema = new schema.Entities('TVs',{
            screen: screens,        
            button: buttons,
            ...
        },'id');
    ```
    * 如果你的电视不是一台，是很多电视，那么则需导出一个适用于数组的schema
    ```js
        const TVListSchema = [ TVSchema ]; 
    ```
    * 当你终于拿到你的一堆电视并要开始拆的时候
    ```js
        const TVs = [ tv1, tv2, tv3 ];
        const TVentities = normalize(TVs,TVListSchema);
    ```
    * 此时你终于拿到了所有零件的集合了
    ```js
        TVentities = {
            Tvs: {...},         //对没错 电视壳子也是零件啊
            screens: {...},
            buttons: {...}
        }
    ```







